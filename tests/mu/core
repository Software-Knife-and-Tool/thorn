assert_eq "(mu:eq 1 1)" ":t"
assert_eq "(mu:eq 1 2)" ":nil"
assert_eq "(mu:eval 'mu:std-in)" "#<stream: id: 2147483648>"
assert_eq "(mu:eval ())" ":nil"
assert_eq "(mu:fix (:lambda (l) (:if l ((:lambda () (mu:write (mu:car l) () mu:std-out) (mu:cdr l))) ())) '(1 2 3 4))" "1234:nil"
assert_eq "(mu:fix (:lambda (l) (:if l ((:lambda () (mu:write (mu:car (mu:car l)) () mu:std-out) (mu:cdr l))) ())) '((0 . 1) (2 . 3)))" "02:nil"
assert_eq "(mu:apply mu:eq '(1 2))" ":nil"
assert_eq "(mu:apply mu:fx-add '(1 2))" "3"
assert_eq "(mu:type-of (mu:real-tm))" ":fixnum"
assert_eq "(mu:type-of (mu:run-us))" ":fixnum"
assert_eq "(mu:type-of #\a)" ":char"
assert_eq "(mu:type-of '(1 2 3))" ":cons"
assert_eq "(mu:type-of '(:lambda ()))" ":cons"
assert_eq "(mu:type-of 'mu:apply)" ":symbol"
assert_eq "(mu:type-of ())" ":null"
assert_eq "(mu:type-of 1)" ":fixnum"
assert_eq "(mu:type-of :typeof)" ":keyword"
assert_eq "(mu:type-of mu:std-in)" ":stream"
assert_eq "(mu:type-of mu:hp-info)" ":func"
assert_eq "(mu:type-of mu:fr-get)" ":func"
assert_eq "(mu:type-of mu:fr-push)" ":func"
assert_eq "(mu:type-of mu:fr-pop)" ":func"
assert_eq "(mu:type-of mu:async)" ":func"
assert_eq "(mu:type-of mu:await)" ":func"
assert_eq '(mu:type-of "type-of")' ":vector"
assert_eq '(mu:view #\a)' "#(:t a)"
assert_eq "(mu:view '(1 2))" "#(:t 1 (2))"
assert_eq '(mu:view 1234)' "#(:t 1234)"
assert_eq '(mu:view 1.0)' "#(:t 1.0000)"
assert_eq "(mu:view #(:t 1 2))" "#(:t 2 :t)"
assert_eq "(mu:view #s(:foo 1 2))" "#(:t :foo #(:t 1 2))"
assert_eq "(mu:view 'a)" '#(:t :nil :extern a :UNBOUND)'
assert_eq "(mu:view 'mu:eq)" '#(:t #<namespace: "mu"> :extern eq #<:function mu:eq [req:2, tag:0]>)'
assert_eq '(mu:view (mu:map-ns "mu"))' "#(:t mu :nil)"
assert_eq "(mu:view mu:std-in)" "#(:t 2147483648 :input :nil :nil)"
assert_eq "(mu:with-ex (:lambda (cond obj) (mu:write cond () mu:std-out)) (:lambda () (mu:fx-div 1 1)))" "1"
