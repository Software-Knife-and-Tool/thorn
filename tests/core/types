(mu:type-of core:define-core-type)	:func
(mu:type-of core:core-type-p)	:func
(mu:type-of core:type-of)	:func
(mu:type-of (mu:eval (core:compile '((:lambda () (core:define-core-type "test" '((:v . :t))) (core:%make-core-type "test" '((:v . 2))))))))	:struct
(core:type-of (mu:eval (core:compile '((:lambda () (core:define-core-type "test" '((:v . :t))) (core:%make-core-type "test" '((:v . 2))))))))	test
((:lambda () (core:define-core-type "test" '((:v . :t))) (core:%core-type-ref :v (core:%make-core-type "test" '((:v . 2))))))	(:v . 2)
(core:typep '(1 2) :cons)	:t
(core:typep 1 :fixnum)	:t
(core:typep (mu:make-st :struct ()) :struct)	:t
(core:typep "abc" :vector)	:t
(core:typep #(:t 1 2 3) :vector)	:t
(core:typep mu:std-in :stream)	:t
(core:typep #\a :char)	:t
(core:typep 1.024e23 :float)	:t
(core:typep (mu:make-mp ()) :map)	:t
(core:typep :foo :keyword)	:t
(core:typep 'foo :symbol)	:t
(core:typep () :null)	:t
(core:typep () 'symbol)	:t
(core:typep () '(satisfies core:null))	:t
(core:typep 1 '(satisfies core:fixnump))	:t
(core:typep 1024e23 '(satisfies core:floatp))	:t
(core:typep '(1 2 3) '(satisfies core:consp))	:t
(core:typep #(:t 1 2 3) '(satisfies core:vectorp))	:t
(core:typep #\a '(satisfies core:charp))	:t
(core:typep () '(not symbol))	:nil
(core:typep () '(and))	:t
(core:typep () '(and (satisfies core:null)))	:t
(core:typep () '(and :null (satisfies core:null)))	:t
(core:typep () '(or))	:nil
(core:typep () '(or (satisfies core:null)))	:t
(core:typep () '(or :null (satisfies core:null)))	:t
(core:typep core:1+ 'function)	:t
(core:typep 1234 'number)	:t
(core:typep 1.024 'number)	:t
(core:typep 1234 'integer)	:t
(core:typep #(:t 1 2 3) 'sequence)	:t
(core:typep "123" 'sequence)	:t
(core:typep '(1 2 3) 'sequence)	:t
(core:typep "abc" 'string)	:t
(core:typep mu:std-in 'stream)	:t
(core:typep :sym 'symbol)	:t
(core:typep 'sym 'symbol)	:t
(core:typep (core:read (core:make-string-stream :input "#*1111") () ()) 'bit-vector)	:t
