
![alt text](https://github.com/Software-Knife-and-Tool/thorn/blob/main/.github/thorn-eth.png?raw=true)

# *thorn* - a system programming environment


### Under heavy development

*thorn* is a LISP-idiomatic functionally-oriented interactive environment for system programming in the Rust ecosystem. It is targeted to low-resource persistent POSIX environments.

*thorn* is a LISP-1 namespaced programming environment with Common Lisp idioms and macro system.

While *thorn* has much in common with Scheme, it is meant to be familiar to traditional LISP programmers.

*thorn* is a 2-Lisp, which gives it considerable flexibility in implementation and subsequent customization. A small, native code runtime kernel supports system classes, function application, heap/system image management, and the FFI framework.



#### Project Goals
------

- functional forward system language
- minimal POSIX runtime suitable for containers
- small and simple installation, no external dependencies
- add interactivity and extensibility to application implementations
- Rust FFI system
- mostly Common Lisp semantics
- resource overhead equivalent to a UNIX shell
- minimal external crate dependencies



#### State of the *thorn* system

------

*thorn* is a work in progress.

*thorn* should build with rust 1.68 or better. *thorn* builds are targeted to:

- x86-64 and AArch-64 Linux distributions
- x86-64 and M1 MacOs X
- x86-64 WSL
- Docker Ubuntu and Alpine containers

Portability, libraries, deployment, documentation, and garbage collection are currently the top priorities.



#### About *thorn*

------

*thorn* is an immutable, namespaced *LISP-1* that borrows heavily from *Scheme*, but is stylistically more closely related to the Common LISP family of languages. *thorn* syntax and constructs will be familiar to the traditional LISP programmer. 

*thorn* leans heavily on functional programming principles.

The *thorn* runtime kernel is written in mostly-safe `rust` (the system image heap facility *mmaps* a file, which is an inherently unsafe operation.)

The *mu* runtime implements 64 bit tagged pointers. The *mu* runtime is available as a crate, extends a Rust API for embedded applications, and is an evaluator for the *mu* kernel language. *mu* provides the usual fixed-width numeric types, lists, fixed-arity lambdas, LISP-1 symbol namespaces, streams, and specialized vectors in a garbage collected environment.

The *thorn* 2-LISP system is organized as a stack of compilers. 

The *core* library provides *rest* lambdas, closures, extended exceptions, *defun/defconst/defmacro* and a compiler for those forms.

*preface* extends *core* with various lexical binding forms, *cond/and/or/progn*, and a library loading facility.

Optional libraries provide a variety of enhancements and services, including Common LISP macros and binding special forms.



#### Viewing the documentation

------

A handy ```thorn-mu``` reference card can be found in ```doc/refcards``` in a variety of formats.

The `thorn-mu` crate rustdoc documentation can be generated by

```
% make doc
```

and will end up in ```doc/rustdoc```. The ``doc/rustdoc/mu``  subdirectory contains the starting ```index.html```.

The *thorn* reference documentation is a collection of *markdown* files in `doc/reference`, currently not installed in the repo.



#### Building and installing the *thorn* system

------

The *thorn* runtime *libmu* is a native code program that must be built for the target CPU architecture. The *thorn* build system requires only a `rust` compiler,`rust-fmt`,`clippy` and some form of the `make` utility. Other tools like  `valgrind` are optional.

Tests and performance measurement requires some version of `python 3`.

```
git clone https://github.com/Software-Knife-and-Tool/thorn.git
```

After cloning the *thorn* repository, the *rust* system can be built and installed with the supplied makefile.

```
% make world
```

Having built the distribution, install it in `/opt/thorn`.

```
% sudo make install
```

Related build targets, `debug` and `profile`, compile for debugging and profiling respectively.

`make` with no arguments prints the available targets.

If you want to repackage *thorn* after a change to the library sources:

```
% make dist
```

and then install.



#### Testing

<hr>

The distribution includes a test suite, which should be run after every interesting change. The test suite consists of a several hundred individual tests separated into multiple sections, roughly separated by namespace.

Failures in the *mu* tests are almost guaranteed to cause complete failure of subsequent tests.

```
% make tests/summary
% make tests/commit
```

The `summary` target produces a test report. This summary will be checked into the repo at the next commit.

 The `commit` target will produce a diff between the current summary and the repo summary.

The `tests` makefile has additional facilities for development, including reporting on individual and all tests. The makefile `help` target will list them.

```
% make -C tests help
```



#### Performance metrics

<hr>
Metrics include the average amount of time (in microsconds) taken for an individual test and the number of objects allocated by that test. Differences between runs in the same installation can be in the 10% range. Any changes in storage consumption or a large (10% or greater) increase in test timing warrant examination.

The NTESTS environment variable (defaults to 20) controls how many passes are included in a single test run.

On a Core I7 CPU at 3+ GHz, the default perf tests take approximately three minutes of elapsed time for the *mu* namespace.

```
% make -C perf base
% make -C perf summary
```

The `base` target produces a performance run and establishes a base line. The `summary` target produces a secondary performance run. The secondary summary will be checked into the repo at the next commit.

The `perf` makefile has additional facilities for development, including reporting on individual tests. The`help` target will list them. 

In specific, a summary of significant performance changes (differences in measured resource consumption and/or a large (%25) difference in average test time between the current summary and the repo summary.)

```
% make -C perf commit
```

produces a report of the differences between the current summary and the established baseline. The *commit* target reports on any change in storage consumption between the baseline and the current summary, and timing changes greater than 20% for any individual test.

For convenience, the *thorn* Makefile provides:

```
% make perf/base	  # establish a baseline summary
% make perf/summary   # produce a secondary summary
% make perf/commit    # produce a condensed report
```



#### Running the *thorn* system

------

The *thorn* binaries, libraries, and source files are installed in `/opt/thorn` . The `bin` directory contains the binaries and shell scripts for running the system. A copy of the `mu` crate is included in `/opt/thorn/thorn` along with the `core` and `preface` library sources.



```
runtime      runtime binary, minimal repl
thorn         shell script for running the extended repl
```


```
OVERVIEW: runtime - posix platform mu interface
USAGE: runtime [options] [file...]

runtime: 0.0.x: [-h?psvcelq] [file...]
OPTIONS:
  -h                   print this message
  -?                   print this message
  -v                   print version string and exit
  -p                   pipe mode, no welcome message or repl
  -l SRCFILE           load SRCFILE in sequence
  -e SEXPR             evaluate SEXPR and print result
  -q SEXPR             evaluate SEXPR quietly
  -c name:value[,...]  environment configuration  	   
  file ...             load source file(s)
  
```

An interactive session for the extended *thorn* system is invoked by the`thorn` shell script, `:h` will print the currently available repl commands. Forms entered at the prompt are evaluated and the results printed. The prompt displays the current namespace.

```
% /opt/thorn/bin/thorn
;;; Thorn LISP version 0.0.x (preface:repl) :h for help
user>
```

*rlwrap* makes the *thorn* and *runtime* repls much more useful, with command history and line editing.

```
% alias ,thorn='rlwrap -m /opt/thorn/bin/thorn'
```

Depending on your version *rlwrap*, may exhibit odd echoing behavior. Adding

```
set enable-bracketed-paste off
```



to your `~/.inputrc` may help.

------

Functional languages bring us closer to a time where we can automatically prove our programs are correct. 

*thorn* attempts to couch modern programming concepts with a familiar syntax.

*LISPs* are intentionally dynamic which has selected against them for use in production environments, yet statically-typed languages produce systems that are hard to interact with and impossible to change *in situ*. Few of the dynamic languages in use today have adequate meta programming facilities. We need systems that can we reason about and can supplement themselves.

Such systems tend to be large and resource-hungry. We need lean systems that can do useful work in low resource environments and are flexible enough to evolve to meet new demands.

Evolutionary response to change is the only defense a system has against obsolescence.

Most, if not all, of our core computational frameworks are built on static systems and are fragile with respect to change. Such systems tend to be disposable. Dynamic systems designed for persistence and change are the next step.
